#!/usr/bin/python -tt

# skvidal, (c) Red Hat, Inc 2012
# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>

# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

# TODO: add 'execution time' option output to the output

import sys
import os
import getpass
import ansible.runner
import shlex
from ansible.scripts import base_ans_parser, error_print


def main(args):


    # ==================================
    # parse options
    parser = base_ans_parser()
    parser.usage = "ans-command [options] command-to-run"

    parser.add_option('-o', '--one-line', dest='one_line', action='store_true', 
        help="output results on one line to make grepping easier, however will \
            not remove newlines from command output")
    parser.add_option('-t', '--tree', dest='output_dest', default=None,
        help="if specified, a directory name to save output to, one file per host")

    options, args = parser.parse_args(args)

    # get user's password if not supplied
    # TODO: move into lib/ansible/scripts.py (?)
    sshpass = None
    if options.askpass:
        sshpass = getpass.getpass(prompt="SSH password: ")

    # if specifying output destination (aka tree output saves), create the 
    # directory to output to

    if options.output_dest:
        if options.output_dest[0] != '/':
            options.output_dest = os.path.realpath(os.path.expanduser(options.output_dest))
        if not os.path.exists(options.output_dest):
            try:
                os.makedirs(options.output_dest)
            except (IOError, OSError), e:
                print >> sys.stderr, "Could not make dir %s: %s" % (options.output_dest, e)
                sys.exit(1)
        if not os.access(options.output_dest, os.W_OK):
            print >> sys.stderr, "Cannot write to path %s" % options.output_dest
            sys.exit(1)

    # if no arguments are specified, error out

    if len(args) == 0:
       print >> sys.stderr, "Missing argument.  What should be executed?"
       sys.exit(1)

    # make the actual ansible API call

    mycmd = ' '.join(args)
    runner = ansible.runner.Runner(
                module_name='command',
                module_path=options.module_path,
                module_args=shlex.split(mycmd),
                remote_user=options.remote_user,
                remote_pass=sshpass,
                host_list=options.host_list,
                forks=options.forks,
                pattern=options.pattern,
                verbose=True,
            )
    results = runner.run()

    # walk through results and summarize them neatly

    for hostname in sorted(results['contacted']):

        result    = results['contacted'][hostname]
        rc        = result.get('rc',0)
        failed    = result.get('failed', 0)
        stdout    = result.get('stdout', '')
        stderr    = result.get('stderr', '')
        traceback = result.get('traceback', '')
        error     = result.get('error', '')

        # detect and show failures, if any

        if rc != 0 or failed:
            msg = "Error: %s: \n" % hostname
            msg += stdout
            msg += stderr
            msg += traceback
            msg += error
            error_print(msg)
            continue

        if options.one_line:
            # try to print everything on one line, but don't strip newlines
            # if the command output happend to be too long
            msg = "(stdout) %s" % stdout
            if stderr.rstrip() != '':
                msg = "(stdout) %s (stderr) %s" % (stdout,stderr)
            print "%s | rc=%s | %s" % (
                hostname, rc, msg
            )
        else:
            # summarize response from command in multiple lines
            buf = ''
            buf += "%s | rc=%s >>\n" % (hostname, rc)
            buf += stdout
            if stderr:
                buf += stderr
            print buf
            if options.output_dest:
                path = os.path.join(options.output_dest, hostname)
                fd = open(path, "w+")
                fd.write(buf)
                fd.close()

    # print errors for hosts we could not reach
    if results['dark']:
        print ''
        error_print('Hosts which could not be contacted or did not respond:')
        failed_hosts = results['dark'].keys()
        for hostname in failed_hosts:
            error_print("%s:\n%s\n" % (hostname, results['dark'][hostname]))
        print ''

    
if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))





