#!/usr/bin/python -tt
#skvidal, (c) Red Hat, Inc 2012

# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

#todo
# add 'execution time' option output to the output

import sys
import os
import getpass
import ansible.runner
import shlex
from ansible.scripts import base_ans_parser, error_print


def main(args):
    parser = base_ans_parser(output_path=False)
    parser.usage = "ans-command [options] command-to-run"
    parser.add_option('-c', '--return-codes', dest='return_codes', action='store_true', 
            help="prefix each line with the commands returncode")
    parser.add_option('-1', '--one-line', dest='one_line', action='store_true', 
            help="output all things as one line - to make grepping easier, will \
                  not remove \\n's from output of commands, though")
    parser.add_option('-o', '--output-dir', dest='output_dest', default=None,
          help="output each host's results to a file in a dir named for the host")
    options, args = parser.parse_args(args)

    sshpass = None
    if options.askpass:
        sshpass = getpass.getpass(prompt="SSH password: ")
    pattern = '*'
    if options.host:
        pattern += ';'.join(options.host)

    if options.output_dest:
        if options.output_dest[0] != '/':
            options.output_dest = os.path.realpath(os.path.expanduser(options.output_dest))
        if not os.path.exists(options.output_dest):
            try:
                os.makedirs(options.output_dest)
            except (IOError, OSError), e:
                print >> sys.stderr, "Could not make dir %s: %s" % (options.output_dest, e)
                sys.exit(1)
        
        if not os.access(options.output_dest, os.W_OK):
            print >> sys.stderr, "Cannot write to path %s" % options.output_dest
            sys.exit(1)

    if len(args) == 0:
       print >> sys.stderr, "Missing argument.  What should be executed?"
       sys.exit(1)

    mycmd = ' '.join(args)
   
    runner = ansible.runner.Runner(
                module_name='command',
                module_path=options.module_path,
                module_args=shlex.split(mycmd),
                remote_user=options.remote_user,
                remote_pass=sshpass,
                host_list=options.host_list,
                forks=options.forks,
                pattern=pattern,
                verbose=True,
            )

    print mycmd
    results = runner.run()

    for hn in sorted(results['contacted']):
        d = results['contacted'][hn]
        if d.get('rc', 0) != 0 or d.get('failed', 0):
            msg = 'Error: %s: ' % hn
            # too bad stdout/stderr is not interleaved :(
            msg += d.get('stdout', '')
            msg += d.get('stderr', '')
            msg += d.get('traceback', '')
            msg += d.get('error', '')
            error_print(msg)
            continue

        if options.output_dest:
            fo = open(options.output_dest + '/' + hn +'.output', 'w')
            fo.write(mycmd + '\n')
            fo.write('%s:\n' % hn)
            if options.return_codes:
                fo.write('return code: %s\n' % d['rc'])
            fo.write('%s\nErrors:\n%s\n' % (d['stdout'], d['stderr']))
            fo.close()
            continue

        if options.one_line:
            if options.return_codes:
                print '%s:%s:%s:%s' % (hn, d['rc'], d['stdout'], d['stderr'])
            else:
                print '%s:%s:%s' % (hn, d['stdout'], d['stderr'])
        else:
            print '%s:' % hn
            if options.return_codes:
                print 'return code:%s\n' % d['rc']
            print '%s' % d['stdout']
            if d.get('stderr', None):
                print '%s' % d['stderr']

    if results['dark']:
        error_print('Hosts which could not be contacted or did not respond:')
        for hn in sorted(results['dark']):
            error_print(hn)
        print ''


    if options.output_dest:
        print "output written to %s" % options.output_dest

    
if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))





